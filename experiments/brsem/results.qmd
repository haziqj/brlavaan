---
title: 'Simulation Results'
format: 
  html: 
    embed-resources: true
    toc: true
    lightbox: true
    fig-width: 7.5
    fig-height: 6
  # pdf: 
  #   fig-width: 7.5
  #   fig-height: 6
execute:
  echo: false
  freeze: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| include: false
library(tidyverse)
library(brlavaan)
library(gt)
library(glue)
library(semPlot)
library(semptools)
here::i_am("experiments/brsem/results.qmd")
load(here::here("experiments/brsem/results.RData"))
```

## Write-up

On success rates

- Success rate is determined as optimiser reporting convergence and an estimate that makes sense.
  - For two-factor models, standard errors must be less than 5.
  - For growth curve models, the standard errors must be less than 500.
  - These two are different due to the scaling of the data.
  - For both models, the implied Sigma covariance matrix is reported to be positive definite.
- In general, the success rates are high for the iBR and eBR methods across all scenarios, but there are a couple of exceptions.
- For n >= 50, this is at least 85% and higher, and convergence is 100% for n = 100 and above.
- The problem arise when n = 15 and 20, in particular for the two-factor model and the eBR method. Note that the convergence is determined by the ML, so the improper estimates come from numerical issues in the derivative of the penalty function in the eBR method.

Two-factor models

- To compare the performance of our methods, we looked at the specific scenario of normally distributed errors with reliability of 0.8. The reason for this is that this scenario gave the best convergence rates across all methods, so a fair comparison could be made.
- The centred distributions of the estimates show high degree of variability in the estimates across all methods, but this became less as sample size increased.
- Our methods always improved the bias over ML estimates particularly in small sample sizes. RMSE was roughly the same for all methods, which suggests that variability in the estimates was similar. This was seen as well in the distribution plot.
- Our method also improved coverage by about 5% at best, particularly in small sample sizes. 
- Comparing our methods to the D&R methods, in terms of relative mean bias, our methods always offered improvement across different reliability settings and also in the non-normal setting. 
- Bias performance was comparable to the other proposed methods including Jackknife and Bootstrap and Ozenne, although typically the resampling methods showed slightly better performance, at a csot of higher variability especially in non-normal settings. Our method did not have this drawback.
- In the non-normal setting, we highlighted the fact that eRBM method had convergence issues in small sample sizes and non-normal distributions, where about 60% of the estimates were rejected. This seemed to affect the bias performance. It is noted however the median bias was close to zero, suggesting that the mean bias was pulled by extreme estimates caused by numerical issues.

Growth model

- For the growth model, the estimates were markedly less variable. This is attributed to the smaller number of parameters needed to be estimated (6 vs 13) [???]
- The performance was similar, whereby we see the performance of our iRBM and eRBM methods giving substantial improvements in bias and coverage, but not in RMSE.
- Additionally, the probability of underestimating the parameters is much closer to the nominal level (i.e. median bias is close to zero), where we also see ML overshooting median bias more than our methods.
- When data is normal, REML gave the best relative mean bias. To be expected... [???], but when data is non-normal, REML gave the worst performance. This is likely due to the fact that REML is not robust to non-normality, and the fact that the data was generated from a non-normal distribution.
- Overall, our methods performed equally well to the resampling and Ozenne methods, giving slightly better performance in some cases.



## Success rates

```{r}
#| label: tbl-convsucc
#| tbl-cap: 'Success rates for estimation of the two-factor model for the ML, eBR, and iBR methods. Highlighted in red are the scenarios which produced success rates below 50%.'
#| html-table-processing: none

gt(res_conv) |>
  tab_spanner(
    columns = matches("twofac.*0\\.8"),
    label = "Reliability = 0.8",
    id = "twofac80"
  ) |>
  tab_spanner(
    columns = matches("twofac.*0\\.5"),
    label = "Reliability = 0.5",
    id = "twofac50"
  ) |>
  tab_spanner(
    columns = starts_with("twofac"),
    label = "Two-factor model"
  ) |>
  tab_spanner(
    columns = matches("growth.*0\\.8"),
    label = "Reliability = 0.8",
    id = "growth80"
  ) |>
  tab_spanner(
    columns = matches("growth.*0\\.5"),
    label = "Reliability = 0.5",
    id = "growth50"
  ) |>
  tab_spanner(
    columns = starts_with("growth"),
    label = "Growth curve model"
  ) |>
  fmt_percent(contains("0."), decimals = 1) |>
  cols_label(
    contains("ML") ~ "ML",
    contains("eRBM") ~ "eRBM",
    contains("iRBM") ~ "iRBM"
  ) |>
  data_color(
    columns = -all_of("n"),
    domain = c(0, 1),
    palette = c("red3", "white",  "white")
  ) |>
  tab_options(table.font.size = "11px")
```

## Timing

```{r}
#| label: tbl-timing
#| tbl-cap: 'Comparison of mean computation times (in seconds, with standard deviations in parentheses) for estimating the two-factor model and growth curve models.'
#| html-table-processing: none
res_timing_n1000 |>
  rowwise() |>
  mutate(
    thing = glue::glue("{gt::vec_fmt_number(mean)} ({gt::vec_fmt_number(sd)})"),
    method = factor(
      method,
      levels = c("ML", "lav", "eRBM", "iRBM", "JB", "BB", "Ozenne", "REML"),
      labels = names(mycols)
    )
  ) |>
  select(-mean, -sd) |>
  pivot_wider(names_from = model, values_from = thing) |>
  arrange(method) |>
  gt() |>
  sub_missing(missing_text = "") |>
  gt::cols_label(
    method = "Method",
    twofac = "Two-factor model",
    growth = "Growth curve model"
  )
```


## Two-factor model

### Path diagram

::: {#fig-path-growth}
```{r pathtwofac, engine = "tikz", out.width = "90%"}
\begin{tikzpicture}
\node[inner sep=3pt] {%
\begin{tikzpicture}[%
  >=stealth,
  auto,
  node distance=1.6cm,
  every node/.style={font=\small},
  latent/.style={circle, draw, minimum size=8mm, inner sep=0mm},
  obs/.style={rectangle, draw, minimum size=7mm, inner sep=0mm},
  error/.style={circle, draw, minimum size=6mm, inner sep=0mm}
]

% --------------------------------------------------------
% 1) LATENT VARIABLES
% --------------------------------------------------------
\node[latent] (eta1) at (-1.5, -2) {$\eta_{1}$};
\node[latent] (eta2) at ( 3, -2) {$\eta_{2}$};

% --------------------------------------------------------
% 2) OBSERVED VARIABLES + ERROR TERMS
%    Place y1..y3 (for eta1) on the left, y4..y6 (for eta2) on the right.
% --------------------------------------------------------
\node[obs] (y1) at (-3, 0) {$y_{1}$};
\node[obs] (y2) at (-1.5, 0) {$y_{2}$};
\node[obs] (y3) at ( 0, 0) {$y_{3}$};

\node[obs] (y4) at ( 1.5, 0) {$y_{4}$};
\node[obs] (y5) at ( 3, 0) {$y_{5}$};
\node[obs] (y6) at ( 4.5, 0) {$y_{6}$};

% Error terms above each observed variable
\node[error] (e1) at (-3, 1.5) {$\epsilon_{1}$};
\node[error] (e2) at (-1.5, 1.5) {$\epsilon_{2}$};
\node[error] (e3) at ( 0, 1.5) {$\epsilon_{3}$};
\node[error] (e4) at ( 1.5, 1.5) {$\epsilon_{4}$};
\node[error] (e5) at ( 3, 1.5) {$\epsilon_{5}$};
\node[error] (e6) at ( 4.5, 1.5) {$\epsilon_{6}$};

% --------------------------------------------------------
% 3) PATHS FROM ERROR TERMS TO OBSERVED VARIABLES
% --------------------------------------------------------
\draw[->] (e1) -- (y1);
\draw[->] (e2) -- (y2);
\draw[->] (e3) -- (y3);
\draw[->] (e4) -- (y4);
\draw[->] (e5) -- (y5);
\draw[->] (e6) -- (y6);

% --------------------------------------------------------
% 4) FACTOR LOADINGS
%    \eta_1 -> y1, y2, y3
%    \eta_2 -> y4, y5, y6
% --------------------------------------------------------
\draw[->] (eta1) -- node[pos=0.5, right] {$\Lambda_{11}$} (y1);
\draw[->] (eta1) -- node[pos=0.5, right] {$\Lambda_{21}$} (y2);
\draw[->] (eta1) -- node[pos=0.5, right] {$\Lambda_{31}$} (y3);

\draw[->] (eta2) -- node[pos=0.5, right] {$\Lambda_{42}$} (y4);
\draw[->] (eta2) -- node[pos=0.5, right] {$\Lambda_{52}$} (y5);
\draw[->] (eta2) -- node[pos=0.5, right] {$\Lambda_{62}$} (y6);

% --------------------------------------------------------
% 5) REGRESSION BETWEEN LATENT VARIABLES
%    \eta_1 -> \eta_2, labeled beta
% --------------------------------------------------------
\draw[->] (eta1) -- node[midway, above] {$\beta$} (eta2);

% --------------------------------------------------------
% 6) VARIANCES OF LATENT VARIABLES
%    Double-headed arrows for psi_{11} and psi_{22}
% --------------------------------------------------------
\draw[<->] (eta1) to[out=200, in=230, looseness=4] 
  node[left] {$\Psi_{11}$} (eta1);

\draw[<->] (eta2) to[out=-50, in=-20, looseness=4] 
  node[right] {$\Psi_{22}$} (eta2);

\end{tikzpicture}
};
\end{tikzpicture}
```
A structural equation model featuring two latent variables, $\eta_{1}$ and $\eta_{2}$, each indicated by three observed variables ($y_{1}$, $y_{2}$, $y_{3}$) for $\eta_{1}$ and ($y_{4}$, $y_{5}$, $y_{6}$) for $\eta_{2}$. Each observed measure has an associated error term $\epsilon_{j}\sim\operatorname{N}(0,\Theta_{jj})$. The latent regression path from $\eta_{1}$ to $\eta_{2}$ is labelled $\beta$. Factor loadings are represented by $\Lambda_{ij}$, and the latent variances by $\Psi_{11}$ and $\Psi_{22}$.
:::

```{r}
#| label: tbl-truth-twofac
#| html-table-processing: none
tibble(
  rel = paste0("Reliability = ", c(0.8, 0.5))
) |>
  mutate(
    truth = list(truth_twofac(0.8), truth_twofac(0.5)),
    param = map(truth, ~ names(.x))
  ) |>
  unnest(c(truth, param)) |> 
  mutate(param = case_when(
    param == "fx=~x2" ~ "$\\Lambda_{2,1}$",
    param == "fx=~x3" ~ "$\\Lambda_{3,1}$",
    param == "fy=~y2" ~ "$\\Lambda_{5,2}$",
    param == "fy=~y3" ~ "$\\Lambda_{6,2}$",
    param == "fy~fx"  ~ "$\\beta$",
    param == "x1~~x1" ~ "$\\Theta_{1,1}$",
    param == "x2~~x2" ~ "$\\Theta_{2,2}$",
    param == "x3~~x3" ~ "$\\Theta_{3,3}$",
    param == "y1~~y1" ~ "$\\Theta_{4,4}$",
    param == "y2~~y2" ~ "$\\Theta_{5,5}$",
    param == "y3~~y3" ~ "$\\Theta_{6,6}$",
    param == "fx~~fx" ~ "$\\Psi_{1,1}$",
    param == "fy~~fy" ~ "$\\Psi_{2,2}$"
  )) |>
  mutate(truth = as.character(truth)) |>
  pivot_wider(names_from = rel, values_from = truth) |>
  gt(rowname_col = "param") |>
  fmt_markdown("param")
```

### Centred distributions for parameters

```{r}
#| label: fig-centdist-twofac
#| fig-cap: 'Centered distributions of estimates for the two-factor model (left panel) using normally generated data at 80% reliability. Non-convergence cases and extreme estimates have been excluded. The right panel displays the number of estimates used to compute the summary statistics.'
#| fig-height: 7.5
#| out-width: 100%

p1 <-
  plot_df |>
  filter(param %in% twofacpars) |> 
  ggplot(aes(bias, param, fill = method)) +
  geom_boxplot(alpha = 0.8, outlier.size = 0.3, linewidth = 0.3) +
  # geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_manual(values = mycols) +
  scale_y_discrete(labels = rev(c(
    expression(Theta["1,1"]),
    expression(Psi["1,1"]),
    expression(Psi["2,2"]),
    expression(beta),
    expression(Lambda["2,1"])
  ))) +
  facet_grid(n ~ .) +
  guides(fill = guide_legend(reverse = TRUE, position = "inside")) +
  theme_bw() +
  theme(
    legend.position.inside = c(0.91, 0.095), 
    legend.background = element_rect(fill = NA), 
    legend.text = element_text(size = 8), 
    legend.title = element_text(size = 9),
    strip.background = element_blank(),
    strip.text = element_blank()    
  ) +
  labs(x = NULL, y = NULL, fill = "Method", subtitle = glue::glue("{plot_df$dist[1]} distribution, reliability = {gsub('Rel = ', '', plot_df$rel[1])}"))

p2 <-
  plot_df |>
  filter(param %in% twofacpars) |> 
  summarise(count = n(), .by = dist:param) |>
  ggplot(aes(count, param, fill = method)) +
  geom_col(width = 0.8, position = position_dodge()) +
  geom_vline(xintercept = 2000, linetype = "dashed") +
  scale_fill_manual(values = mycols) +
  scale_x_continuous(expand = c(0, 0, 0, 100)) +
  facet_grid(n ~ .) +
  theme_bw() +
  theme(
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank(), 
    axis.text.x = element_text(size = 7.5), 
    legend.position = "none"
  ) +
  labs(x = NULL, y = NULL, subtitle = " ")

cowplot::plot_grid(p1, p2, rel_widths = c(1, 1 / 3))
```

### Performance plots

```{r}
#| label: fig-perf-twofac
#| fig-cap: 'Performance metrics (relative bias, RMSE, probability of understimation, and coverage) of the ML, eBR, and iBR methods for estimation of the two-factor model. Vertical dashed lines indicate the ideal values for each metric.'
#| fig-height: 7
#| out-width: 100%
plot_df |> 
  filter(param %in% twofacpars) |> 
  summarise(
    B = mean(bias, na.rm = TRUE, trim = 0.05),
    rmse = sqrt(mean(bias ^ 2, na.rm = TRUE, trim = 0.05)),
    pu = mean(bias < 0),
    covr = mean(covered, na.rm = TRUE),
    .by = c(dist:param)
  ) |>
  pivot_longer(B:covr, names_to = "metric", values_to = "value") |>
  mutate(
    metric = factor(
      metric,
      levels = c("B", "rmse", "pu", "covr"),
      labels = c("Bias", "RMSE", "Prob. underest.", "Coverage")
    )
  ) |>
  ggplot(aes(value, param, fill = method)) +
  geom_col(position = "dodge", width = 0.75) +
  geom_vline(
    data = tibble(
      metric = factor(c("Bias", "RMSE", "Prob. underest.", "Coverage")),
      value = c(0, 0, 0.5, 0.95)
    ),
    aes(xintercept = value),
    linetype = "dashed"
  ) +
  scale_fill_manual(values = mycols) +
  facet_grid(n ~ metric, scales = "free_x") +
  ggh4x::facetted_pos_scales(
    x = list(
      scale_x_continuous(),
      scale_x_continuous(expand = c(0, 0, 0, 0.1)),
      scale_x_continuous(limits = c(0.3, 0.7), labels = scales::percent),
      scale_x_continuous(limits = c(0.6, 1), labels = scales::percent)
    )
  ) +
  scale_y_discrete(labels = rev(c(
    expression(Theta["1,1"]),
    expression(Psi["1,1"]),
    expression(Psi["2,2"]),
    expression(beta),
    expression(Lambda["2,1"])
  ))) +
  guides(fill = guide_legend(reverse = TRUE, position = "bottom")) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 7.5),
    legend.key.height = unit(1, "pt"), 
    legend.key.width = unit(9, "pt")
  ) +
  labs(x = NULL, y = NULL, fill = NULL, subtitle = glue::glue("{plot_df$dist[1]} distribution, reliability = {gsub('Rel = ', '', plot_df$rel[1])}"))
```

### Comparison to other methods

```{r}
#| label: fig-meanbias-twofac
#| fig-cap: 'Comparison of relative mean bias of the ML, eBR, and iBR methods against the D&R methods for estimation of the two-factor model.'
#| out-width: 100%

plot_drcomp |>
  filter(model == "twofac", !method %in% c("lav")) |>
  ggplot(aes(n, relbias, col = method)) +
  geom_line(linewidth = 0.75, alpha = 1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  ggh4x::facet_nested(param ~ rel + dist, labeller = label_parsed) +
  scale_color_manual(values = mycols) +
  scale_x_continuous(labels = c(15, 20, 50, 100, 1000)) +
  scale_y_continuous(labels = scales::percent) +
  # coord_cartesian(ylim = c(-0.3, 0.3)) +
  guides(colour = guide_legend(nrow = 1, reverse = TRUE, position = "top")) +
  theme_bw() +
  labs(x = "Sample size (n)", y = glue("Relative mean bias"), col = NULL)
```

```{r}
#| label: fig-rmse-twofac
#| fig-cap: 'Comparison of RMSE of the ML, eBR, and iBR methods against the D&R methods for estimation of the two-factor model.'
#| out-width: 100%

plot_drcomp |>
  filter(model == "twofac", !method %in% c("lav")) |>
  mutate(method = fct_rev(method)) |>
  ggplot(aes(n, rmse, fill = method)) +
  geom_col(position = "dodge", width = 0.75) +
  scale_x_continuous(breaks = 1:5, labels = c(15, 20, 50, 100, 1000)) +
  ggh4x::facet_nested(param ~ rel + dist, labeller = label_parsed) +
  scale_fill_manual(values = mycols) +
  guides(fill = guide_legend(nrow = 1, position = "bottom")) +
  theme_bw() +
  theme(legend.key.height = unit(1, "pt"), legend.key.width = unit(9, "pt")) +
  labs(x = "Sample size (n)", y = "RMSE", fill = NULL)
```

## Growth curve model

### Path diagram

::: {#fig-path-growth}
```{r pathgrowth, engine = "tikz"}
\usetikzlibrary{shapes.geometric,arrows,calc,positioning}
\begin{tikzpicture}
\node[inner sep=3pt] {%
\begin{tikzpicture}[%
  >=stealth,              % for arrow tips
  auto,                   % automatic label positioning
  node distance=1.6cm,
  every node/.style={font=\small},
  latent/.style={circle, draw, minimum size=8mm, inner sep=0mm},
  obs/.style={rectangle, draw, minimum size=7mm, inner sep=0mm},
  error/.style={circle, draw, minimum size=6mm, inner sep=0mm},
intercept/.style={regular polygon, regular polygon sides=3, draw, inner sep=0pt, minimum size=6mm}
  ]

%-------------------------------------------------------
% 1) LATENT FACTORS (intercept i, slope s)
%-------------------------------------------------------
\node[latent] (i) at (-2,-3) {$i$};
\node[latent] (s) at ( 2,-3) {$s$};
\node[intercept] (int1) at (-2,-4.2) {\footnotesize 1};
\node[intercept] (int2) at (2,-4.2) {\footnotesize 1};

%-------------------------------------------------------
% 2) COVARIANCES AMONG LATENT FACTORS
%    - psi_{11} on i
%    - psi_{22} on s
%    - psi_{21} between i and s
%-------------------------------------------------------
% i <-> s
\draw[<->] (i) to[out=-45, in=225] node[below] {$\Psi_{12}$} (s);

% Variance of i
\draw[<->] (i) to[out=190, in=220, looseness=4] 
  node[left] {$\Psi_{11}$} (i);

% Variance of s
\draw[<->] (s) to[out=-40, in=-10, looseness=4] 
  node[right] {$\Psi_{22}$} (s);

\draw[->] (int1) -- node[right,pos=0.3] {$\alpha_1$} (i);
\draw[->] (int2) -- node[right,pos=0.3] {$\alpha_2$} (s);

%-------------------------------------------------------
% 3) OBSERVED VARIABLES (y1..y10) + ERRORS (eps1..eps10)
%    Arrange them in a horizontal row above i and s.
%-------------------------------------------------------
\foreach \j in {1,...,10} {
  % X-position for y_j (shift them so they are roughly centered)
  \pgfmathsetmacro{\x}{(\j*1.3 - 6.5)}

  % Observed variable y_j
  \node[obs] (y\j) at (\x,0) {$y_{\j}$};

  % Error term epsilon_j above y_j
  \node[error] (e\j) at (\x,1.5) {$\epsilon_{\j}$};

  % Arrow from error to observed
  \draw[->] (e\j) -- (y\j);

  % Intercept factor loadings: all = 1
  \draw[->] (i) -- node[pos=0.45,right] {\footnotesize 1} (y\j);

  % Slope factor loadings: 0..9
  \pgfmathtruncatemacro{\loading}{\j - 1}
  \draw[->] (s) -- node[pos=0.7,right] {\footnotesize\loading} (y\j);
}

\end{tikzpicture}
};
\end{tikzpicture}
```
A schematic of a univariate latent growth curve model with intercept ($i$) and slope ($s$) factors measured over 10 time points ($y_1$--$y_{10}$). Each observed measure has an associated error term ($\epsilon_j\sim\operatorname{N}(0,\theta)$). The intercept factor loadings are fixed to 1, while slope factor loadings increment from 0 to 9, and $\Psi_{11}$, $\Psi_{22}$, and $\Psi_{12}$ denote the variances and covariance of the latent factors.
:::

```{r}
#| label: tbl-truth-growth
#| html-table-processing: none
tibble(
  rel = paste0("Reliability = ", c(0.8, 0.5))
) |>
  mutate(
    truth = list(truth_growth(0.8), truth_growth(0.5)),
    param = map(truth, ~ names(.x))
  ) |>
  unnest(c(truth, param)) |>
  distinct(rel, truth, param, .keep_all = TRUE) |>
  mutate(param = case_when(
    param == "v" ~ "$\\theta$",
    param == "i~~i" ~ "$\\Psi_{1,1}$",
    param == "s~~s" ~ "$\\Psi_{2,2}$",
    param == "i~~s" ~ "$\\Psi_{1,2}$",
    param == "i~1" ~ "$\\alpha_1$",
    param == "s~1" ~ "$\\alpha_2$",
  )) |>
  mutate(ord = case_when(
    grepl("Psi", param) ~ 3,
    grepl("alpha", param) ~ 1,
    grepl("theta", param) ~ 2
  )) |>
  arrange(ord) |>
  select(-ord) |>
  mutate(truth = as.character(truth)) |>
  pivot_wider(names_from = rel, values_from = truth) |>
  gt(rowname_col = "param") |>
  fmt_markdown("param")
```

### Centred distributions for parameters

```{r}
#| label: fig-centdist-growth
#| fig-cap: 'Centered distributions of estimates for the growth curve model (left panel) using normally generated data at 80% reliability. Non-convergence cases and extreme estimates have been excluded. The right panel displays the number of estimates used to compute the summary statistics.'
#| fig-height: 7.5
#| out-width: 100%

p1 <-
  plot_df |>
  filter(param %in% growthpars) |> 
  ggplot(aes(bias, param, fill = method)) +
  geom_boxplot(alpha = 0.8, outlier.size = 0.3, linewidth = 0.3) +
  # geom_vline(xintercept = 0, linetype = "dashed") +
  scale_fill_manual(values = mycols) +
  scale_y_discrete(labels = rev(c(
    expression(Theta["1,1"]),
    expression(Psi["1,1"]),
    expression(Psi["2,2"]),
    expression(Psi["1,2"])
  ))) +
  facet_grid(n ~ .) +
  guides(fill = guide_legend(reverse = TRUE, position = "inside")) +
  theme_bw() +
  theme(
    legend.position.inside = c(0.89, 0.095), 
    legend.background = element_rect(fill = NA), 
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 9),
    strip.background = element_blank(),
    strip.text = element_blank()     
  ) +
  labs(x = NULL, y = NULL, fill = "Method", subtitle =  glue::glue("{plot_df$dist[1]} distribution, reliability = {gsub('Rel = ', '', plot_df$rel[1])}"))

p2 <-
  plot_df |>
  filter(param %in% growthpars) |> 
  summarise(count = n(), .by = dist:param) |>
  ggplot(aes(count, param, fill = method)) +
  geom_col(width = 0.8, position = position_dodge()) +
  geom_vline(xintercept = 2000, linetype = "dashed") +
  scale_fill_manual(values = mycols) +
  scale_x_continuous(expand = c(0, 0, 0, 100)) +
  facet_grid(n ~ .) +
  theme_bw() +
  theme(
    axis.text.y = element_blank(), 
    axis.ticks.y = element_blank(), 
    axis.text.x = element_text(size = 7.5), 
    legend.position = "none"
  ) +
  labs(x = NULL, y = NULL, subtitle = " ")

cowplot::plot_grid(p1, p2, rel_widths = c(1, 1 / 3))
```

### Performance plots

```{r}
#| label: fig-perf-growth
#| fig-cap: 'Performance metrics (relative bias, RMSE, probability of understimation, and coverage) of the ML, eBR, and iBR methods for estimation of the growth curve model. Vertical dashed lines indicate the ideal values for each metric.'
#| fig-height: 7
#| out-width: 100%
plot_df |>
  filter(param %in% growthpars) |> 
  summarise(
    B = mean(bias, na.rm = TRUE, trim = 0.05),
    rmse = sqrt(mean(bias ^ 2, na.rm = TRUE, trim = 0.05)),
    pu = mean(bias < 0),
    covr = mean(covered, na.rm = TRUE),
    .by = c(dist:param)
  ) |>
  pivot_longer(B:covr, names_to = "metric", values_to = "value") |>
  mutate(
    metric = factor(
      metric,
      levels = c("B", "rmse", "pu", "covr"),
      labels = c("Bias", "RMSE", "Prob. underest.", "Coverage")
    )
  ) |>
  ggplot(aes(value, param, fill = method)) +
  geom_col(position = "dodge", width = 0.75) +
  geom_vline(
    data = tibble(
      metric = factor(c("Bias", "RMSE", "Prob. underest.", "Coverage")),
      value = c(0, 0, 0.5, 0.95)
    ),
    aes(xintercept = value),
    linetype = "dashed"
  ) +
  scale_fill_manual(values = mycols) +
  facet_grid(n ~ metric, scales = "free_x") +
  ggh4x::facetted_pos_scales(
    x = list(
      scale_x_continuous(),
      scale_x_continuous(expand = c(0, 0, 0, 10)),
      scale_x_continuous(limits = c(0.35, 0.65), labels = scales::percent),
      scale_x_continuous(limits = c(0.6, 1), labels = scales::percent)
    )
  ) +
  scale_y_discrete(labels = rev(c(
    expression(Theta["1,1"]),
    expression(Psi["1,1"]),
    expression(Psi["2,2"]),
    expression(Psi["1,2"])
  ))) +
  guides(fill = guide_legend(reverse = TRUE, position = "bottom")) +
  theme_bw() +
  theme(
    axis.text.x = element_text(size = 7.5),
    legend.key.height = unit(1, "pt"), 
    legend.key.width = unit(9, "pt")
  ) +  
  labs(x = NULL, y = NULL, fill = NULL, subtitle = glue::glue("{plot_df$dist[1]} distribution, reliability = {gsub('Rel = ', '', plot_df$rel[1])}"))
```

### Comparison to other methods

```{r}
#| label: fig-meanbias-growth
#| fig-cap: 'Comparison of relative mean bias of the ML, eBR, and iBR methods against the D&R methods for estimation of the growth curve model.'
#| out-width: 100%

plot_drcomp |>
  filter(model == "growth", !method %in% c("lav")) |>
  ggplot(aes(n, relbias, col = method)) +
  geom_line(linewidth = 0.75, alpha = 1) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  ggh4x::facet_nested(param ~ rel + dist, labeller = label_parsed) +
  scale_color_manual(values = mycols) +
  scale_x_continuous(labels = c(15, 20, 50, 100, 1000)) +
  scale_y_continuous(labels = scales::percent) +
  # coord_cartesian(ylim = c(-0.25, 0.25)) +
  guides(colour = guide_legend(nrow = 1, reverse = TRUE, position = "top")) +
  theme_bw() +
  labs(x = "Sample size (n)", y = "Relative mean bias", col = NULL)
```

```{r}
#| label: fig-rmse-growth
#| fig-cap: 'Comparison of RMSE of the ML, eBR, and iBR methods against the D&R methods for estimation of the growth curve model.'
#| out-width: 100%

plot_drcomp |>
  filter(model == "growth", !method %in% c("lav")) |>
  mutate(method = fct_rev(method)) |>
  ggplot(aes(n, rmse, fill = method)) +
  geom_col(position = "dodge", width = 0.75) +
  scale_x_continuous(breaks = 1:5, labels = c(15, 20, 50, 100, 1000)) +
  ggh4x::facet_nested(param ~ rel + dist, labeller = label_parsed) +
  scale_fill_manual(values = mycols) +
  # coord_cartesian(ylim = c(0, 280)) +
  guides(fill = guide_legend(nrow = 1, position = "bottom")) +
  theme_bw() +
  theme(legend.key.height = unit(1, "pt"), legend.key.width = unit(9, "pt")) +
  labs(x = "Sample size (n)", y = "RMSE", fill = NULL)
```

## Tables

```{r}
#| label: tbl-bias-twofac-80
#| tbl-cap: 'Results (trimmed) two-factor model reliability 0.80.'
#| html-table-processing: none
#| column: page

tab_bias(bias_twofac_80_df, "twofac")
```

```{r}
#| label: tbl-bias-twofac-50
#| tbl-cap: 'Results (trimmed) two-factor model reliability 0.50.'
#| column: page
#| html-table-processing: none

tab_bias(bias_twofac_50_df, "twofac")
```

```{r}
#| label: tbl-covr-twofac
#| tbl-cap: 'Coverage rates 95% confidence interval for the two-factor model.'
#| column: page
#| html-table-processing: none

tab_covr(covr_twofac_df, "twofac")
```

```{r}
#| label: tbl-bias-growth-80
#| tbl-cap: 'Results (trimmed) growth curve model reliability 0.80.'
#| html-table-processing: none
#| column: page

tab_bias(bias_growth_80_df, "growth")
```

```{r}
#| label: tbl-bias-growth-50
#| tbl-cap: 'Results (trimmed) growth curve model reliability 0.50.'
#| column: page
#| html-table-processing: none

tab_bias(bias_growth_50_df, "growth")
```

```{r}
#| label: tbl-covr-growth
#| tbl-cap: 'Coverage rates 95% confidence interval for the growth curve model.'
#| column: page
#| html-table-processing: none

tab_covr(covr_growth_df, "growth")
```
